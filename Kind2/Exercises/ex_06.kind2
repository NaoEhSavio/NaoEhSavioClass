Bool : Type
Bool.true : Bool
Bool.false : Bool

Bool.eql (a: Bool) (b: Bool) : Bool
Bool.eql Bool.true Bool.true = Bool.true
Bool.eql Bool.true Bool.false = Bool.false
Bool.eql Bool.false Bool.true = Bool.false
Bool.eql Bool.false Bool.false = Bool.true

Bool.not (a: Bool) : Bool
Bool.not Bool.true  = Bool.false
Bool.not Bool.false = Bool.true

Bool.if <r: Type> (b: Bool) (if_t: r) (if_f: r) : r
Bool.if r Bool.true  if_t if_f = if_t
Bool.if r Bool.false if_t if_f = if_f

// Integer Exercises

// Integers
Inte : Type
Inte.neg(num: Neg) : Inte 
Inte.pos(num: Pos) : Inte 

// Positive Numbers
Pos : Type 
Pos.zero : Pos
Pos.succ(pred: Pos) : Pos 

// Negative Numbers
Neg : Type
Neg.one : Neg
Neg.pred(succ: Neg) : Neg

// example
// -0 does not exist
// Increments a negative number by one
// neg_succ(n: Neg): Neg
//   case n { 
//     one:  Neg.one
//     pred: n.succ
//   }

// Functions for negative numbers to help testing 
// Do not edit those functions

// Converts Neg to Nat
// neg_to_nat(n: Neg): Nat
//   case n { 
//     one:  Nat.succ(Nat.zero)
//     pred: Nat.succ(neg_to_nat(n.succ))
//   }
  
// Converts Nat to Neg
// nat_to_neg(n: Nat): Neg
//   neg_succ(nat_to_neg_aux(n))
  
  // Aux function for Nat.to_neg
// nat_to_neg_aux(n: Nat): Neg
//   case n {
//     zero: Neg.one
//     succ: Neg.pred(nat_to_neg_aux(n.pred))
//   }

// Converts Pos to Nat
// pos_to_nat(n: Pos): Nat
//   case n { 
//     zero:  Nat.zero
//     succ:  Nat.succ(pos_to_nat(n.pred))
//   }

// Converts Nat to Pos
// nat_to_pos(n: Nat): Pos
//   case n { 
//     zero: Pos.zero
//     succ: Pos.succ(nat_to_pos(n.pred))
//   }

// Converts Pos to String
// pos_show(n: Pos): String
//   "+"|Nat.show(pos_to_nat(n))

// Converts Neg to String
// neg_show(n: Neg): String
//   "-"|Nat.show(neg_to_nat(n))

// Converts Int to String
// inte_show(n: Inte): String
//   case n {
//     neg: neg_show(n.num) 
//     pos: pos_show(n.num) 
//   }

// Creates an int sign
// true  = Positive 
// false = Negative
// int(sign: Bool, num: Nat): Inte
//   case sign {
//     true: Inte.pos(nat_to_pos(num))
//     false:
//       case num {
//         zero: Inte.pos(Pos.zero)
//         succ: Inte.neg(nat_to_neg(num))
//       }
//   }


// Exercises:

// Increments an Integer
// int(false, 1)     = +0
// int(false, 2)     = -1
// int(true,  2)     = +3
Inte.inc (a: Inte): Inte  
Inte.inc (Inte.pos a)            = (Inte.pos(Pos.succ a))
Inte.inc (Inte.neg (Neg.one))    = (Inte.pos(Pos.zero))
Inte.inc (Inte.neg (Neg.pred a)) = (Inte.neg(a))

// Decrements an Integer
// int(false, 1) = -2
// int(true,  2) = +1
// int(true,  0) = -1
Inte.dec (a: Inte): Inte
Inte.dec (Inte.pos (Pos.succ a)) = (Inte.pos(a))
Inte.dec (Inte.pos (Pos.zero))   = (Inte.neg(Neg.one))
Inte.dec (Inte.neg a)            = (Inte.neg(Neg.pred a))

// Doubles an Integer
// int(false, 4) = -8
// int(false, 1) = -2
// int(true,  2) = +4
Inte.dbl (a: Inte): Inte 
Inte.dbl (Inte.pos (Pos.zero))    = (Inte.pos(Pos.zero))
Inte.dbl (Inte.pos (Pos.succ a))  = (Inte.inc(Inte.inc(Inte.dbl(Inte.pos a))))
Inte.dbl (Inte.neg (Neg.one))     = (Inte.neg(Neg.pred(Neg.one)))
Inte.dbl (Inte.neg (Neg.pred a))  = (Inte.dec(Inte.dec(Inte.dbl(Inte.neg a))))

// Adds two Integers
// int(false, 4) + int(false, 2) = -6
// int(false, 4) + int(true,  2) = -2
Inte.add (a: Inte) (b: Inte): Inte
Inte.add (Inte.pos (Pos.zero))    (Inte.pos (Pos.zero))   = (Inte.pos (Pos.zero))
Inte.add (Inte.pos a) (Inte.pos   (Pos.zero))             = (Inte.pos a)
Inte.add (Inte.pos (Pos.zero))    (Inte.pos b)            = (Inte.pos b)
Inte.add (Inte.pos (Pos.succ a))  (Inte.pos (Pos.succ b)) = (Inte.inc(Inte.inc(Inte.add (Inte.pos a) (Inte.pos b))))
Inte.add (Inte.neg (Neg.one))     (Inte.neg (Neg.one))    = (Inte.neg(Neg.pred(Neg.one)))
Inte.add (Inte.neg a)             (Inte.neg (Neg.one))    = (Inte.neg(Neg.pred a))
Inte.add (Inte.neg (Neg.one))     (Inte.neg b)            = (Inte.neg(Neg.pred b))
Inte.add (Inte.neg (Neg.pred a))  (Inte.neg (Neg.pred b)) = (Inte.dec(Inte.dec(Inte.add (Inte.neg a) (Inte.neg b))))
Inte.add (Inte.neg (Neg.one))     (Inte.pos (Pos.zero))   = (Inte.neg (Neg.one))
Inte.add (Inte.neg a)             (Inte.pos (Pos.zero))   = (Inte.neg a)
Inte.add (Inte.pos (Pos.zero))    (Inte.neg (Neg.one))    = (Inte.neg (Neg.one))
Inte.add (Inte.pos (Pos.zero))    (Inte.neg b)            = (Inte.neg b)
Inte.add (Inte.pos a)             (Inte.neg b)            = ?
Inte.add (Inte.neg a)             (Inte.pos b)            = ?
// Inte.add (Inte.neg a) (Inte.pos (Pos.zero))               = 

// Multiplies two Integers
// int(false, 2) * int(true, 3)  = -6
// int(false, 4) * int(false, 5) = +20
//-1 * -10 = 10
Inte.mul(a: Inte) (b: Inte): Inte

// Subtracts two Integers
// int(false, 6) - int(false, 6) = +0
// // int(false, 4) - int(false, 6) = +2
Inte.sub(a: Inte) (b: Inte): Inte

// // Equal
Inte.eql(a: Inte) (b: Inte): Bool // Given two Integers, returns true if both are the same and false otherwise.


// // Greater than
// // int(false, 2) > int(false, 5) = True
// // int(false, 5) > int(false, 1) = False
// // int(false, 2) > int(true,  0) = False
// // int(true,  0) > int(false, 2) = True
Inte.gtn(a: Inte) (b: Inte): Bool // if A > B then True else false


// // Lower than
// // int(false, 1) < int(true,  0) = True
// // int(true,  0) < int(false, 1) = False
Inte.ltn(a: Inte) (b: Inte): Bool // if A > B then False else true


// // Minimum
// // min(int(false, 1), int(true,  0)  = -1
// // min(int(false, 1), int(false, 3)) = -3
Inte.min(a: Inte) (b: Inte): Inte // if A < B then A else B

// // Maximum
// // max(int(false, 1), int(true,  0)) = +0
// // max(int(false, 1), int(false, 3)) = -1
Inte.max(a: Inte) (b: Inte): Inte // if A > B then A else B

// // Half
// // Divides an Integer by two
// // int(false, 4) = -2
// // int(false, 1) = +0
// // int(true,  6) = +3
Inte.hlf(a: Inte): Inte

// // Division
// // int(true,  2)  / int(true,  2)  = +1
// // int(false, 8)  / int(true,  4)  = -2
// // int(false, 11) / int(false, 5)  = +2
// // int(true,  10) / int(false, 12) = +0
Inte.div(a: Inte) (b: Inte): Inte 


Main {
  let a = (Inte.neg(Neg.one))
  let b = (Inte.neg(Neg.pred(Neg.one)))
  let c = (Inte.pos(Pos.zero))
  let d = (Inte.pos(Pos.succ(Pos.zero)))
  (Inte.dbl b)
}