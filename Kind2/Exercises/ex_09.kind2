
List <a: Type> : Type
List.nil <a> : (List a)
List.cons <a> (head: a) (tail: List a) : (List a)

Maybe <a: Type> : Type
Maybe.none <a> : (Maybe a)
Maybe.some <a> (value: a) : (Maybe a)

Pair (a: Type) (b: Type) : Type
Pair.new <a> <b> (fst: a) (snd: b) : (Pair a b) 

Nat : Type
Nat.zero : Nat
Nat.succ(pred: Nat) : Nat

Bool : Type
Bool.true : Bool
Bool.false : Bool

Bool.if <a: Type> (b: Bool) (t: a) (f: a) : a
Bool.if a Bool.true  t f = t
Bool.if a Bool.false t f = f

Nat.ltn (a: Nat) (b: Nat): Bool
Nat.ltn Nat.zero Nat.zero = Bool.false
Nat.ltn a        Nat.zero = Bool.false
Nat.ltn Nat.zero b        = Bool.true
Nat.ltn (Nat.succ a) (Nat.succ b) = (Nat.ltn a b)

Nat.min (a: Nat) (b: Nat): Nat
Nat.min a b = if (Nat.ltn a b) { a } else { b }

//// Returns pairs of the elements of the 2 input lists on the same index
// Ex: zip!!([1,2], ["a","b","c"]) == [{1, "a"}, {2 , "b"}]
// Ex: zip!!(["a", "b"], [3, 5])   == [{"a", 3}, {2 , "b"}]
List.zip <a: Type> <b: Type> (xs: List a) (ys: List b) : (List (Pair a b))
List.zip a b (List.nil xs) ys = (List.nil (Pair a b))
List.zip a b xs (List.nil ys) = (List.nil (Pair a b))
List.zip a b (List.cons xs xs.head xs.tail) (List.cons ys ys.head ys.tail) = List.cons (Pair.new xs.head ys.head) (List.zip xs.tail ys.tail)

// Returns the smallest element of a List
List.smallest (xs: (List Nat)) : (Maybe Nat)
List.smallest (List.nil xs) = Maybe.none
List.smallest (List.cons xs head (List.nil Nat)) = Maybe.some head
List.smallest (List.cons xs head (List.cons tail.xs tail.head tail.tail)) = List.smallest( List.cons (Nat.min head tail.head) tail.tail)



// Returns the value inside the Maybe.
// If there is no value contained, returns v instead
Maybe.extract <a: Type> (m: Maybe a) (v: a) : a
Maybe.extract a (Maybe.none m)  v = v
Maybe.extract a (Maybe.some m value) v = value

// // Returns the same list without the smallest element
List.delete_smallest (xs: (List Nat)) : (List Nat)
List.delete_smallest (List.nil xs) = (List.nil Nat)
List.delete_smallest (List.cons xs head (List.nil Nat)) = (List.nil Nat)
List.delete_smallest (List.cons xs head (List.cons tail.xs tail.head tail.tail)) = 
    List.cons tail.head (List.delete_smallest( List.cons (Nat.min head tail.head) tail.tail))
// List.delete_smallest (List.cons xs head tail) =  if (Nat.ltn head (Maybe.extract (List.smallest xs) (Nat.zero))) {tail} else {List.cons head (List.delete_smallest tail)}

// // Returns the same list, in ascending order
List.sort_ascending (xs: (List Nat)): (List Nat)
List.sort_ascending (List.nil xs) = List.nil Nat
List.sort_ascending xs = List.cons ((Maybe.extract (List.smallest xs) (Nat.zero))) (List.sort_ascending( List.delete_smallest xs))

// // Returns an element at an index from the list
// // if there is an element at that index
// //   returns Maybe.some!(element)
// // else
// //   returns Maybe.none!
// get<A: Type>(idx: Nat, xs: List<A>): Maybe<A>
//   case xs{
//     nil: Maybe.none<A>
//     cons: case idx {
//       zero: Maybe.some<A>(xs.head) 
//       succ: get<A>(idx.pred, xs.tail)
//     }
//   }

// // Removes all elements that does not match a condition
// // List.filter<Nat>(Nat.odd, [1, 2, 3, 4, 5]) = [1, 3, 5]
// filter<A: Type>(f: A -> Bool, xs: List<A>): List<A>
//   case xs {
//     nil: List.nil<A>
//     cons: case f(xs.head){
//       true:List.cons<A>(xs.head, filter<A>(f, xs.tail))
//       false: filter<A>(f, xs.tail)
//     }
//   }
Main {
    let a = [(Nat.succ(Nat.succ(Nat.succ(Nat.zero)))),
             (Nat.succ(Nat.zero)), 
             (Nat.succ(Nat.succ(Nat.zero))), 
             (Nat.succ(Nat.succ(Nat.succ(Nat.zero)))), 
             (Nat.succ(Nat.succ(Nat.succ(Nat.succ(Nat.zero))))),
             (Nat.succ(Nat.succ(Nat.succ(Nat.succ(Nat.succ(Nat.zero))))))]
    let b = List.nil
    List. a
}